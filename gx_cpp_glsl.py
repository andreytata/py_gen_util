#!/usr/bin/env python
# coding: utf-8

import sys, re, json, weakref

from gx_gltf_make import (Gltf, DagTree, gxDagTree)

class QtTemplate:
    def __init__(self, self_pri, mesh_key):
        self.weak_pri = weakref.ref(self_pri)
        self.mesh_key = mesh_key
        self.slots = []
        pass #print("++%s" % self)

    def get_name(self):
        source = self.weak_pri()
        shared = source.gxt.get_mesh_name(self.mesh_key)
        return shared

    def get_name_lower(self):
        return self.get_name().lower()

    def get_name_upper(self):
        return self.get_name().upper()

    def gen_public_slots(self):
        buff = "//PUBLIC SLOTS\n"
        for i in self.slots:
            buff += i.generate(self)
        return buff

    def __call__(self, match):
        return str(getattr(self, match.groups()[0])())
    
    def __del__(self):
        pass #print("--%s" % self)

class QtGpuSkin(QtTemplate):
    template = """
    class QtGpuSkin_%%get_name_lower%%: public GeometryEngine
    {
        QOBJECT
    public:
        virtual void drawGeometry(QOpenGLShaderProgram *program);
        virtual void initGeometry();
        const char* get_vbo_signature() { return "%%gen_signature%%"; }

    public slots:
        %%gen_public_slots%%
    };
    """
    glsl_vertex_attribute = dict(
        P3 = ( 'vec4' , 'a_position'  , 'QVector3D' ),
        N3 = ( 'vec4' , 'a_normal'    , 'QVector3D' ),
        T2 = ( 'vec2' , 'a_texCoord0' , 'QVector2D' ),
    )
    attributes = []
    slots = []
    changed = True

    def gen_signature(self):
        return "".join(['P3','N3','W4','J4','T2'])

    def get_class_definition(self):
        return re.sub("%%(\\w+)%%", self, self.template)

class QtGpuMesh(QtTemplate):
    template = """
    class gxGpuMesh_%%get_name_lower%%: public GeometryEngine
    {
        QOBJECT
    public:
        virtual void drawGeometry(QOpenGLShaderProgram *program);
        virtual void initGeometry();
        const char* get_vbo_signature() { return "%%gen_signature%%"; }
    public slots:
        %%gen_public_slots%%
    };
    """
    glsl_vertex_attribute = dict(
        P3 = ( 'vec4' , 'a_position'  , 'QVector3D' ),
        N3 = ( 'vec4' , 'a_normal'    , 'QVector3D' ),
        T2 = ( 'vec2' , 'a_texCoord0' , 'QVector2D' ),
    )
    attributes = []
    slots = []
    changed = True
    def gen_signature(self):
        return "".join(['P3','N3','T2'])

    def get_class_definition(self):
        return re.sub("%%(\\w+)%%", self, self.template)

    def set_mesh_sources(self, PWD, GTX, KEY, VBO, vertices, IBO, indices ):
        self.name = GTX.source.gltf.path

    def get_vbo_as_cpp_code(self):
        return "/*get_vbo_as_cpp_code*/"

    def generate(self, context):
        if self.changed:
            context.get_name()
            self.changed = False
        
    def pprint(self, out = sys.stdout):
        out.write("Hello .pprint Method%s" % self)

class QtGltfBuiltinPri:
    """ Single QT-PRI project from glTF2.0 Resource Generator"""
    pri_file_template = """Autogenerated Builtin Resource PRI %%get_name%%. Do not edit.
# Usage:
#   include(../gx_gen_%%get_name%%/gx_gen_%%get_name%%.pri)

!contains ( INCLUDEPATH, $$PWD ) {
  HEADERS     += $$PWD/gx_gen_%%get_name%%.h
  SOURCES     += $$PWD/gx_gen_%%get_name%%.cpp
  INCLUDEPATH += $$PWD
  include($$PWD/../gx_src_geom/gx_src_geom.pri)
}
"""
    h_file_template = """#ifndef GX_GENERATED_%%GET_NAME%%_H
#define GX_GENERATED_%%GET_NAME%%_H

#include <gx_src_glsl.h>

namespace geom { namespace %%get_name_lower%% {
%%get_class_list%%
}  //geom::%%get_name_lower%%

#endif // GX_GENERATED_%%GET_NAME%%_H
"""

    def __init__(self, NAME, SRC, DST, PRI):
        self.class_defs = []
        self.name     = NAME
        self.src_gltf = SRC  # normal absolute path to source file
        self.out_dir  = DST  # normal absolute path to destination folder
        self.out_pri  = PRI  # normal absolute path to qt project include file
        self.out_md5  = self.out_pri + '.builtin'
        print('')

    def __call__(self, match):
        return str(getattr(self, match.groups()[0])())

    def get_name(self):
        return self.name

    def get_name_lower(self):
        return self.get_name().lower()

    def GET_NAME(self):
        return self.get_name().upper()

    def get_pri_buff(self):
        return re.sub("%%(\\w+)%%", self, self.pri_file_template)

    def get_h_file(self):
        return re.sub("%%(\\w+)%%", self, self.h_file_template)

    def get_class_list (self) :
        class_definitions = []
        for gen_class in self.class_defs:
            class_definitions.append( gen_class.get_class_definition() )
        return "".join(class_definitions)

    def generate(self):
        STORED_MD5 = {}
        try:
            with open(self.out_pri + ".builtins", "r") as f:
                STORED_MD5 = json.loads(f.read())['MD5']
        except IOError   : print("GENERATE: '.builtins' file not found")
        except KeyError  : print("GENERATE, 'md5' not stored in '.builtins' file")
        except ValueError: print("GENERATE, '.builtins' file invalid")

        #!!!TODO: if each stored-md5 equal current md5 => return, else rebuild all
        for i in STORED_MD5:
            print(i, STORED_MD5[i])
        self.rebuild_all()
    
    def rebuild_all(self):
        pri_buff = self.get_pri_buff()
        print(pri_buff)
        print("GENERATE: generate %s" % self.out_dir )
        gltf = Gltf(self.src_gltf)
        dag  = DagTree(gltf)
        self.gxt = gxDagTree(dag)
        print("  skin count %d" % len(gltf.skins))
        print("  mesh count %d" % len(gltf.meshes))
        print("  mtrl count %d" % len(gltf.materials))
        mesh_keys = set(self.gxt.get_mesh_keys())
        for mesh_key in mesh_keys:
            vertex_attributes =  self.gxt.get_mesh_attributes(mesh_key)
            mode = ('mesh', 'skin') [ u'WEIGHTS_0' in vertex_attributes ]
            print("  %s[%s] %s %s" % (mode, mesh_key, self.gxt.get_mesh_name(mesh_key), vertex_attributes))
            if mode == 'skin':
                self.generate_skin_source(mesh_key)
            else:
                self.generate_mesh_source(mesh_key)
        gen_h_buff = self.get_h_file()
        print( gen_h_buff )
        pass

    def get_vertex_signature(self, mesh_key):
        signature = ''
        vertex_attributes =  self.gxt.get_mesh_attributes(mesh_key)
        if u'POSITION'   in vertex_attributes: signature += 'P3'
        if u'NORMAL'     in vertex_attributes: signature += 'N3'
        if u'WEIGHTS_0'  in vertex_attributes: signature += 'W4'
        if u'JOINTS_0'   in vertex_attributes: signature += 'J4'
        if u'TEXCOORD_0' in vertex_attributes: signature += 'T2'
        return signature

    def generate_skin_source(self, mesh_key):
        print("  SKIN[%d] %s" % ( mesh_key, self.gxt.get_mesh_name(mesh_key) ) )
        self.class_defs.append(QtGpuSkin(self, mesh_key))
        method_name = 'get_interleaved_'  + self.get_vertex_signature( mesh_key )
        method = getattr( self.gxt, method_name )
        vertices, vbo = method( mesh_key )
        indices, ibo = self.gxt.get_indices_PP( mesh_key )
        print("  %s" % repr( ( vertices, len(vbo), indices, len(ibo) ) ) )

    def generate_mesh_source(self, mesh_key):
        """Generate h and cpp file additional objects:
        First method, each primitive create self own .h file for each primitive.
        Use namespac e, to separate generated geometry primitives, one from other.
        Use scene name as "namespace" for all this scene geometry, camera, e.t.c.
        """
        print("  MESH[%d] %s" % ( mesh_key, self.gxt.get_mesh_name(mesh_key) ) )
        self.class_defs.append(QtGpuMesh(self, mesh_key))
        method_name = 'get_interleaved_'  + self.get_vertex_signature( mesh_key )
        method = getattr(self.gxt, method_name)
        vertices, vbo = method( mesh_key )
        indices, ibo = self.gxt.get_indices_PP( mesh_key )
        print("  %s" % repr( ( vertices, len(vbo), indices, len(ibo) ) ) )


if __name__ =='__main__':
    test = QtGltfBuiltinPri('Slava_Rig_2'
        , 'C:/work/EXP61/devicea/gx_fbx_test/Slava_Rig_2014_2015_NEW.gltf'
        , 'C:/WORK/GEN/gx_gen_Slava_Rig_2'
        , 'C:/WORK/GEN/gx_gen_BoxTextured/gx_gen_Slava_Rig_2.pri'
    )
    test.generate()
